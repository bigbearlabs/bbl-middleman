// Generated by CoffeeScript 1.6.2
(function() {
  var app;

  app = this.appModule;

  this.appModule.factory('evernoteSvc', function($log, $http) {
    var obj;

    obj = {
      fetchStickers: function(page) {
        if (page === null) {
          return Q.fcall(function() {
            return obj.listTags();
          }).then(function(tags) {
            var matchingTags, stickers;

            obj.ifError(tags, Q);
            $log.info(tags);
            matchingTags = tags.filter(function(tag) {
              return tag.name.match(app.userPrefs.sticker_prefix_pattern);
            });
            stickers = matchingTags.map(function(tag) {
              var sticker;

              return sticker = new Sticker({
                implObj: tag,
                id: tag.guid,
                name: tag.name
              });
            });
            return stickers;
          });
        } else {
          throw "don't call me for page stickers.";
        }
      },
      fetchPage: function(params) {
        return Q.fcall(function() {
          return obj.fetchNote({
            url: params.url
          });
        }).then(function(result) {
          var page, pageData, _ref;

          pageData = {
            url: params.url,
            title: params.title,
            stickers: result != null ? (_ref = result.tags) != null ? _ref.map(function(tag) {
              return {
                name: tag.name,
                guid: tag.guid
              };
            }) : void 0 : void 0,
            note: result
          };
          pageData.stickers || (pageData.stickers = []);
          page = new Page(pageData);
          return page;
        });
      },
      createSticker: function(newSticker) {
        return obj.persist('sticker', newSticker);
      },
      updateSticker: function(newSticker) {
        return obj.persist('sticker', newSticker);
      },
      deleteSticker: function(sticker) {
        sticker.name = "archived - " + sticker.name;
        return obj.persist('sticker', sticker);
      },
      persist: function(type, modelObj) {
        var htmlSafeUrl, _ref;

        switch (type) {
          case 'page':
            htmlSafeUrl = _.escape(modelObj.url);
            return obj.saveNote({
              guid: (_ref = modelObj.note) != null ? _ref.guid : void 0,
              title: modelObj.title,
              content: "On " + (new Date()) + ", you stickered the page <a href='" + (encodeURI(htmlSafeUrl)) + "'>'" + modelObj.title + "'</a>.",
              tags: modelObj.stickers.concat({
                name: 'TagYeti'
              }),
              thumbnail: modelObj.thumbnailUrl,
              url: modelObj.url
            });
          case 'sticker':
            if (modelObj.id) {
              modelObj.implObj.name = modelObj.name;
              return obj.updateTag(modelObj.implObj);
            } else {
              return obj.createTag(modelObj).then(function(tag) {
                return new Sticker({
                  id: tag.guid,
                  name: tag.name,
                  implObj: tag
                });
              });
            }
        }
      },
      options: {
        consumerKey: "sohocoke",
        consumerSecret: "80af1fd7b40f65d0",
        evernoteHostName: "https://www.evernote.com"
      },
      init: function() {
        var noteStoreProtocol, noteStoreTransport;

        obj.authToken = app.userPrefs.authToken;
        obj.noteStoreURL = app.userPrefs.noteStoreURL;
        if (!(obj.authToken && obj.noteStoreURL && obj.authToken !== typeof void 0)) {
          throw {
            msg: "couldn't initialise service access from localStorage",
            errorType: "authentication"
          };
        }
        noteStoreTransport = new Thrift.BinaryHttpTransport(obj.noteStoreURL);
        noteStoreProtocol = new Thrift.BinaryProtocol(noteStoreTransport);
        return obj.noteStore = new NoteStoreClient(noteStoreProtocol);
      },
      listTags: function() {
        var deferred;

        deferred = Q.defer();
        obj.noteStore.listTags(obj.authToken, function(results) {
          obj.ifError(results, deferred);
          return deferred.resolve(results);
        });
        return deferred.promise;
      },
      createTag: function(tagData) {
        var deferred, tag;

        deferred = Q.defer();
        tag = new Tag();
        tag.name = tagData.name;
        obj.noteStore.createTag(obj.authToken, tag, function(result) {
          obj.ifError(result, deferred);
          return deferred.resolve(result);
        });
        return deferred.promise;
      },
      updateTag: function(tag) {
        var deferred;

        deferred = Q.defer();
        obj.noteStore.updateTag(obj.authToken, tag, function(err, result) {
          obj.ifError(err, deferred);
          return deferred.resolve(result);
        });
        return deferred.promise;
      },
      deleteTag: function(tag) {
        var deferred;

        deferred = Q.defer();
        obj.noteStore.updateTag(obj.authToken, tag, function(err, result) {
          obj.ifError(err, deferred);
          return deferred.resolve(result);
        });
        return deferred.promise;
      },
      fetchNote: function(args) {
        var deferred, filter, pageSize, spec,
          _this = this;

        deferred = Q.defer();
        pageSize = 10;
        filter = new NoteFilter();
        filter.order = NoteSortOrder.UPDATED;
        filter.words = "sourceURL:" + args.url;
        spec = new NotesMetadataResultSpec();
        spec.includeTitle = true;
        spec.includeTagGuids = true;
        obj.noteStore.findNotesMetadata(obj.authToken, filter, 0, pageSize, spec, function(notesMetadata) {
          var fetchTags, note, noteMd, _ref;

          obj.ifError(notesMetadata, deferred);
          $log.info({
            msg: "fetched notes",
            filter: filter,
            spec: spec,
            notesMetadata: notesMetadata
          });
          if (notesMetadata.notes.length > 1) {
            $log.warn({
              msg: "multiple results for " + args.url
            }, notesMetadata);
          }
          noteMd = notesMetadata.notes[0];
          if (noteMd) {
            fetchTags = (_ref = noteMd.tagGuids) != null ? _ref.map(function(tagGuid) {
              var d2;

              d2 = Q.defer();
              obj.noteStore.getTag(obj.authToken, tagGuid, function(tag) {
                obj.ifError(tag, d2.reject);
                return d2.resolve(tag);
              });
              return d2.promise;
            }) : void 0;
            note = {
              guid: noteMd.guid,
              url: args.url,
              tags: []
            };
            if (fetchTags) {
              return Q.all(fetchTags).then(function(tags) {
                note.tags = tags;
                return deferred.resolve(note);
              });
            } else {
              return deferred.resolve(note);
            }
          } else {
            $log.info("no note matching " + args.url);
            return deferred.resolve(null);
          }
        });
        return deferred.promise;
      },
      saveNote: function(args) {
        var ab, attrs, data, deferred, e, i, ia, note, resource, thumbnailData, thumbnailDataB64, thumbnailMd5Hex, _i, _len;

        deferred = Q.defer();
        note = new Note();
        note.title = args.title;
        note.tagNames = args.tags.map(function(tag) {
          if (!tag.name) {
            throw "invalid tag: " + tag;
          }
          return tag.name;
        });
        attrs = new NoteAttributes();
        attrs.sourceURL = args.url;
        note.attributes = attrs;
        thumbnailDataB64 = _(args.thumbnail.split(',')).last();
        thumbnailData = atob(thumbnailDataB64);
        ab = new ArrayBuffer(thumbnailData.length);
        ia = new Uint8Array(ab);
        for (i = _i = 0, _len = thumbnailData.length; _i < _len; i = ++_i) {
          e = thumbnailData[i];
          ia[i] = thumbnailData.charCodeAt(i);
        }
        thumbnailData = ia;
        thumbnailMd5Hex = faultylabs.MD5(thumbnailData);
        data = new Data();
        data.size = thumbnailData.length;
        data.body = thumbnailData;
        data.bodyHash = thumbnailMd5Hex;
        resource = new Resource();
        resource.mime = 'image/jpeg';
        resource.data = data;
        note.resources = [resource];
        note.content = "<!DOCTYPE en-note SYSTEM \"http://xml.evernote.com/pub/enml2.dtd\">\n<en-note style=\"word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;\">\n  <div>" + args.content + "</div>\n  <en-media type=\"image/jpeg\" hash=\"" + thumbnailMd5Hex + "\" width=\"100%\"/>\n</en-note>";
        if (args.guid) {
          note.guid = args.guid;
          obj.noteStore.updateNote(obj.authToken, note, function(callback) {
            obj.ifError(callback, deferred);
            $log.info({
              msg: 'note updated',
              callback: callback
            });
            return deferred.resolve(note);
          });
        } else {
          obj.noteStore.createNote(obj.authToken, note, function(callback) {
            obj.ifError(callback, deferred);
            $log.info({
              msg: 'note saved',
              callback: callback
            });
            note.guid = callback.guid;
            return deferred.resolve(note);
          });
        }
        return deferred.promise;
      },
      ifError: function(result, deferred) {
        var _ref;

        if (result.parameter === 'authenticationToken') {
          result.errorType = 'authentication';
          return deferred.reject(result);
        } else {
          if (result.type === "error" || ((_ref = result.name) != null ? _ref.match(/Exception/) : void 0)) {
            return deferred.reject(result);
          }
        }
      }
    };
    return obj;
  });

}).call(this);
